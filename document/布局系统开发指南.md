# 布局系统开发指南

## 概述

本项目采用多布局模式系统，允许用户在游戏开始前选择不同的界面布局。所有布局共享同一套游戏核心逻辑，只需实现不同的视图展示和交互方式。

## 现有布局

1. **正常模式** (`NormalLayout.vue`)：传统扇形手牌布局
2. **平铺模式** (`FlatLayout.vue`)：三行固定网格，无障碍设计
3. **竖向模式** (`VerticalLayout.vue`)：占位文件，待实现

## 如何添加新布局

### 第一步：创建布局组件

在 `src/layouts/` 目录下创建新的 Vue 组件，例如 `MyLayout.vue`：

```vue
<template>
  <view class="my-layout">
    <!-- 你的布局 UI -->
  </view>
</template>

<script setup>
import { computed } from 'vue';

// 必须接收的 props
const props = defineProps({
  gameData: { type: Object, required: true },   // 游戏状态
  voiceState: { type: Object, required: true }, // 语音状态
  isRed: { type: Function, required: true },    // 判断红色牌
  getCardName: { type: Function, required: true }, // 获取牌名
  speak: { type: Function, required: true }     // 语音播报
});

// 必须发出的事件
const emit = defineEmits([
  'play',           // 出牌
  'pass',           // 过牌
  'callLandlord',   // 叫地主
  'passLandlord',   // 不叫地主
  'voiceStart',     // 开始录音
  'voiceEnd'        // 停止录音
]);

// 计算属性示例
const handCards = computed(() => props.gameData.players[0].cards);
const stage = computed(() => props.gameData.stage);

// 事件处理示例
const onPlayClick = () => {
  const selected = handCards.value.filter(c => c.selected);
  emit('play', selected);
};
</script>

<style scoped>
/* 你的样式 */
</style>
```

### 第二步：注册布局

在 `src/pages/index/index.vue` 中注册新布局：

```javascript
// 1. 导入组件
import MyLayout from '@/layouts/MyLayout.vue';

// 2. 添加到布局选项
const layoutOptions = [
  { value: 'normal', label: '正常模式', desc: '传统扇形手牌布局' },
  { value: 'flat', label: '平铺模式', desc: '三行固定网格' },
  { value: 'vertical', label: '竖向模式', desc: '纵向排列布局' },
  { value: 'my', label: '我的布局', desc: '自定义布局描述' } // 新增
];

// 3. 添加到组件映射
const layoutComponentMap = {
  normal: markRaw(NormalLayout),
  flat: markRaw(FlatLayout),
  vertical: markRaw(VerticalLayout),
  my: markRaw(MyLayout) // 新增
};
```

### 第三步：实现必要的接口

#### 3.1 Props 说明

| Prop | 类型 | 说明 |
|------|------|------|
| `gameData` | Object | 游戏状态对象，包含 `stage`, `turn`, `landlord`, `players`, `lastPlayedCards` 等 |
| `voiceState` | Object | 语音状态，包含 `isRecording` |
| `isRed` | Function | 判断牌是否为红色 `(card) => boolean` |
| `getCardName` | Function | 获取牌的名称 `(card) => string` |
| `speak` | Function | 语音播报 `(text) => void` |

#### 3.2 Events 说明

| Event | 参数 | 说明 |
|-------|------|------|
| `play` | `selectedCards: Array` | 玩家出牌，传入选中的牌数组 |
| `pass` | 无 | 玩家过牌 |
| `callLandlord` | 无 | 玩家叫地主 |
| `passLandlord` | 无 | 玩家不叫地主 |
| `voiceStart` | 无 | 开始语音录音 |
| `voiceEnd` | 无 | 停止语音录音 |

#### 3.3 GameData 结构

```javascript
{
  stage: 'ready' | 'calling' | 'playing',  // 游戏阶段
  turn: 0 | 1 | 2,                          // 当前回合 (0=玩家, 1/2=AI)
  landlord: -1 | 0 | 1 | 2,                 // 地主 (-1=未定)
  holeCards: Array,                         // 底牌
  lastPlayedCards: Array,                   // 上家出的牌
  lastPlayer: -1 | 0 | 1 | 2,               // 上家玩家
  passStatus: [false, false, false],        // 各玩家是否过牌
  players: [
    { id: 0, cards: [] },  // 玩家手牌
    { id: 1, cards: [] },  // AI1 手牌
    { id: 2, cards: [] }   // AI2 手牌
  ]
}
```

#### 3.4 Card 结构

```javascript
{
  suit: '♠' | '♥' | '♣' | '♦' | '',  // 花色
  label: '3' | '4' | ... | 'K' | 'A' | '2' | '小王' | '大王',
  value: 3-17,                        // 牌值 (3-17)
  selected: false                     // 是否被选中
}
```

## 布局开发最佳实践

### 1. 状态管理
- **不要直接修改 `gameData`**，通过 emit 事件通知父组件
- 使用 `computed` 计算属性访问游戏状态
- 布局内部可以有自己的 UI 状态（如动画、高亮等）

### 2. 选牌逻辑
- **正常模式**：直接修改 `card.selected` 属性
- **平铺模式**：使用 `useFlatLayoutAdapter` 管理选中状态
- 如果需要支持语音指令选牌，暴露 `setSelectedCards` 方法：

```javascript
defineExpose({
  setSelectedCards,  // (cards: Array) => void
  resetSelection     // () => void
});
```

### 3. 语音反馈
- 所有重要操作都应该有语音播报
- 使用 `props.speak(text)` 进行播报
- 考虑防抖处理，避免语音重叠

### 4. 无障碍设计
- 使用高对比度配色
- 提供震动反馈 `uni.vibrateShort()` / `uni.vibrateLong()`
- 按钮尺寸足够大，易于触摸
- 避免单纯依赖颜色区分状态

### 5. 性能优化
- 使用 `v-show` 而非 `v-if` 切换频繁的元素
- 大列表使用虚拟滚动
- 避免在模板中使用复杂计算，使用 `computed`

## 示例：实现竖向模式

```vue
<template>
  <view class="vertical-layout">
    <!-- 顶部信息 -->
    <view class="top-info">
      <text>{{ statusText }}</text>
    </view>

    <!-- 中部牌桌 -->
    <view class="table">
      <!-- AI 玩家 -->
      <view class="ai-players">
        <view class="ai-player">AI1: {{ cardCounts[1] }}张</view>
        <view class="ai-player">AI2: {{ cardCounts[2] }}张</view>
      </view>

      <!-- 上家出牌 -->
      <view class="last-play">
        <view v-for="card in lastPlayedCards" :key="card" class="card">
          {{ card.label }}
        </view>
      </view>
    </view>

    <!-- 底部手牌（纵向排列） -->
    <view class="hand-area">
      <scroll-view scroll-y class="hand-scroll">
        <view 
          v-for="(card, i) in handCards" 
          :key="i"
          class="card-item"
          :class="{selected: card.selected}"
          @click="toggleCard(i)"
        >
          <text>{{ card.label }}{{ card.suit }}</text>
        </view>
      </scroll-view>
    </view>

    <!-- 操作按钮 -->
    <view class="actions">
      <button @click="onPassClick">不出</button>
      <button @click="onPlayClick">出牌</button>
    </view>
  </view>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  gameData: { type: Object, required: true },
  voiceState: { type: Object, required: true },
  isRed: { type: Function, required: true },
  getCardName: { type: Function, required: true },
  speak: { type: Function, required: true }
});

const emit = defineEmits(['play', 'pass', 'callLandlord', 'passLandlord', 'voiceStart', 'voiceEnd']);

const handCards = computed(() => props.gameData.players[0].cards);
const lastPlayedCards = computed(() => props.gameData.lastPlayedCards);
const cardCounts = computed(() => props.gameData.players.map(p => p.cards.length));
const statusText = computed(() => {
  if (props.gameData.stage === 'calling') return '抢地主中';
  if (props.gameData.turn === 0) return '你的回合';
  return '电脑思考';
});

const toggleCard = (index) => {
  if (props.gameData.turn === 0) {
    handCards.value[index].selected = !handCards.value[index].selected;
  }
};

const onPlayClick = () => {
  const selected = handCards.value.filter(c => c.selected);
  emit('play', selected);
};

const onPassClick = () => {
  emit('pass');
};
</script>

<style scoped>
.vertical-layout {
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: #1a5e20;
  color: white;
}

.hand-area {
  flex: 1;
  overflow: hidden;
}

.hand-scroll {
  height: 100%;
}

.card-item {
  padding: 20rpx;
  margin: 10rpx;
  background: white;
  color: #333;
  border-radius: 10rpx;
}

.card-item.selected {
  background: #ffeb3b;
}
</style>
```

## 调试技巧

1. **查看游戏状态**：在浏览器控制台输入 `window.__gameData__` 查看当前游戏状态
2. **测试语音指令**：在控制台调用 `window.__processCommand__('对三')` 测试语音识别
3. **模拟AI出牌**：在控制台调用 `window.__aiPlay__(1)` 触发AI出牌

## 常见问题

### Q: 如何在布局中访问 AI 配置？
A: 不需要。AI 逻辑完全在 `useGameCore` 中处理，布局只负责展示和交互。

### Q: 如何实现自定义的选牌逻辑？
A: 可以参考 `useFlatLayoutAdapter`，创建自己的适配器 composable。

### Q: 布局切换会丢失游戏状态吗？
A: 不会。布局切换只在游戏开始前进行，游戏进行中不可切换。

### Q: 如何支持语音指令？
A: 暴露 `setSelectedCards` 方法，父组件会在语音识别后调用此方法。

## 参考资料

- [Vue 3 Composition API](https://vuejs.org/guide/extras/composition-api-faq.html)
- [UniApp 组件规范](https://uniapp.dcloud.net.cn/component/)
- [无障碍设计指南](https://www.w3.org/WAI/WCAG21/quickref/)
